
TS_Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003c  00800200  00000568  0000061c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000568  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000016a  0080023c  0080023c  00000658  2**0
                  ALLOC
  3 .eeprom       000000ac  00810000  00810000  00000658  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000030  00000000  00000000  00000704  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000734  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000100  00000000  00000000  00000778  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001820  00000000  00000000  00000878  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000dfb  00000000  00000000  00002098  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000009d0  00000000  00000000  00002e93  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000194  00000000  00000000  00003864  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000080e  00000000  00000000  000039f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000003a3  00000000  00000000  00004206  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000070  00000000  00000000  000045a9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	88 c0       	rjmp	.+272    	; 0x112 <__ctors_end>
   2:	00 00       	nop
   4:	a5 c0       	rjmp	.+330    	; 0x150 <__bad_interrupt>
   6:	00 00       	nop
   8:	a3 c0       	rjmp	.+326    	; 0x150 <__bad_interrupt>
   a:	00 00       	nop
   c:	a1 c0       	rjmp	.+322    	; 0x150 <__bad_interrupt>
   e:	00 00       	nop
  10:	9f c0       	rjmp	.+318    	; 0x150 <__bad_interrupt>
  12:	00 00       	nop
  14:	9d c0       	rjmp	.+314    	; 0x150 <__bad_interrupt>
  16:	00 00       	nop
  18:	9b c0       	rjmp	.+310    	; 0x150 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	99 c0       	rjmp	.+306    	; 0x150 <__bad_interrupt>
  1e:	00 00       	nop
  20:	97 c0       	rjmp	.+302    	; 0x150 <__bad_interrupt>
  22:	00 00       	nop
  24:	95 c0       	rjmp	.+298    	; 0x150 <__bad_interrupt>
  26:	00 00       	nop
  28:	93 c0       	rjmp	.+294    	; 0x150 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	91 c0       	rjmp	.+290    	; 0x150 <__bad_interrupt>
  2e:	00 00       	nop
  30:	8f c0       	rjmp	.+286    	; 0x150 <__bad_interrupt>
  32:	00 00       	nop
  34:	8d c0       	rjmp	.+282    	; 0x150 <__bad_interrupt>
  36:	00 00       	nop
  38:	8b c0       	rjmp	.+278    	; 0x150 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	89 c0       	rjmp	.+274    	; 0x150 <__bad_interrupt>
  3e:	00 00       	nop
  40:	87 c0       	rjmp	.+270    	; 0x150 <__bad_interrupt>
  42:	00 00       	nop
  44:	85 c0       	rjmp	.+266    	; 0x150 <__bad_interrupt>
  46:	00 00       	nop
  48:	83 c0       	rjmp	.+262    	; 0x150 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	81 c0       	rjmp	.+258    	; 0x150 <__bad_interrupt>
  4e:	00 00       	nop
  50:	80 c0       	rjmp	.+256    	; 0x152 <__vector_20>
  52:	00 00       	nop
  54:	7d c0       	rjmp	.+250    	; 0x150 <__bad_interrupt>
  56:	00 00       	nop
  58:	7b c0       	rjmp	.+246    	; 0x150 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	79 c0       	rjmp	.+242    	; 0x150 <__bad_interrupt>
  5e:	00 00       	nop
  60:	77 c0       	rjmp	.+238    	; 0x150 <__bad_interrupt>
  62:	00 00       	nop
  64:	75 c0       	rjmp	.+234    	; 0x150 <__bad_interrupt>
  66:	00 00       	nop
  68:	73 c0       	rjmp	.+230    	; 0x150 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	71 c0       	rjmp	.+226    	; 0x150 <__bad_interrupt>
  6e:	00 00       	nop
  70:	6f c0       	rjmp	.+222    	; 0x150 <__bad_interrupt>
  72:	00 00       	nop
  74:	6d c0       	rjmp	.+218    	; 0x150 <__bad_interrupt>
  76:	00 00       	nop
  78:	6b c0       	rjmp	.+214    	; 0x150 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	69 c0       	rjmp	.+210    	; 0x150 <__bad_interrupt>
  7e:	00 00       	nop
  80:	67 c0       	rjmp	.+206    	; 0x150 <__bad_interrupt>
  82:	00 00       	nop
  84:	65 c0       	rjmp	.+202    	; 0x150 <__bad_interrupt>
  86:	00 00       	nop
  88:	63 c0       	rjmp	.+198    	; 0x150 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	61 c0       	rjmp	.+194    	; 0x150 <__bad_interrupt>
  8e:	00 00       	nop
  90:	5f c0       	rjmp	.+190    	; 0x150 <__bad_interrupt>
  92:	00 00       	nop
  94:	5d c0       	rjmp	.+186    	; 0x150 <__bad_interrupt>
  96:	00 00       	nop
  98:	5b c0       	rjmp	.+182    	; 0x150 <__bad_interrupt>
  9a:	00 00       	nop
  9c:	59 c0       	rjmp	.+178    	; 0x150 <__bad_interrupt>
  9e:	00 00       	nop
  a0:	57 c0       	rjmp	.+174    	; 0x150 <__bad_interrupt>
  a2:	00 00       	nop
  a4:	55 c0       	rjmp	.+170    	; 0x150 <__bad_interrupt>
  a6:	00 00       	nop
  a8:	53 c0       	rjmp	.+166    	; 0x150 <__bad_interrupt>
  aa:	00 00       	nop
  ac:	51 c0       	rjmp	.+162    	; 0x150 <__bad_interrupt>
  ae:	00 00       	nop
  b0:	4f c0       	rjmp	.+158    	; 0x150 <__bad_interrupt>
  b2:	00 00       	nop
  b4:	4d c0       	rjmp	.+154    	; 0x150 <__bad_interrupt>
  b6:	00 00       	nop
  b8:	4b c0       	rjmp	.+150    	; 0x150 <__bad_interrupt>
  ba:	00 00       	nop
  bc:	49 c0       	rjmp	.+146    	; 0x150 <__bad_interrupt>
  be:	00 00       	nop
  c0:	47 c0       	rjmp	.+142    	; 0x150 <__bad_interrupt>
  c2:	00 00       	nop
  c4:	45 c0       	rjmp	.+138    	; 0x150 <__bad_interrupt>
  c6:	00 00       	nop
  c8:	43 c0       	rjmp	.+134    	; 0x150 <__bad_interrupt>
  ca:	00 00       	nop
  cc:	7c c0       	rjmp	.+248    	; 0x1c6 <__vector_51>
  ce:	00 00       	nop
  d0:	3f c0       	rjmp	.+126    	; 0x150 <__bad_interrupt>
  d2:	00 00       	nop
  d4:	3d c0       	rjmp	.+122    	; 0x150 <__bad_interrupt>
  d6:	00 00       	nop
  d8:	3b c0       	rjmp	.+118    	; 0x150 <__bad_interrupt>
  da:	00 00       	nop
  dc:	39 c0       	rjmp	.+114    	; 0x150 <__bad_interrupt>
  de:	00 00       	nop
  e0:	37 c0       	rjmp	.+110    	; 0x150 <__bad_interrupt>
  e2:	00 00       	nop
  e4:	b2 01       	movw	r22, r4
  e6:	dc 01       	movw	r26, r24
  e8:	7f 01       	movw	r14, r30
  ea:	7f 01       	movw	r14, r30
  ec:	c7 01       	movw	r24, r14
  ee:	8c 01       	movw	r16, r24
  f0:	7f 01       	movw	r14, r30
  f2:	7f 01       	movw	r14, r30
  f4:	7f 01       	movw	r14, r30
  f6:	7f 01       	movw	r14, r30
  f8:	7f 01       	movw	r14, r30
  fa:	7f 01       	movw	r14, r30
  fc:	7f 01       	movw	r14, r30
  fe:	7f 01       	movw	r14, r30
 100:	7f 01       	movw	r14, r30
 102:	e4 01       	movw	r28, r8
 104:	92 01       	movw	r18, r4
 106:	7f 01       	movw	r14, r30
 108:	98 01       	movw	r18, r16
 10a:	7f 01       	movw	r14, r30
 10c:	7f 01       	movw	r14, r30
 10e:	9e 01       	movw	r18, r28
 110:	b8 01       	movw	r22, r16

00000112 <__ctors_end>:
 112:	11 24       	eor	r1, r1
 114:	1f be       	out	0x3f, r1	; 63
 116:	cf ef       	ldi	r28, 0xFF	; 255
 118:	d1 e2       	ldi	r29, 0x21	; 33
 11a:	de bf       	out	0x3e, r29	; 62
 11c:	cd bf       	out	0x3d, r28	; 61
 11e:	00 e0       	ldi	r16, 0x00	; 0
 120:	0c bf       	out	0x3c, r16	; 60

00000122 <__do_copy_data>:
 122:	12 e0       	ldi	r17, 0x02	; 2
 124:	a0 e0       	ldi	r26, 0x00	; 0
 126:	b2 e0       	ldi	r27, 0x02	; 2
 128:	e8 e6       	ldi	r30, 0x68	; 104
 12a:	f5 e0       	ldi	r31, 0x05	; 5
 12c:	00 e0       	ldi	r16, 0x00	; 0
 12e:	0b bf       	out	0x3b, r16	; 59
 130:	02 c0       	rjmp	.+4      	; 0x136 <__do_copy_data+0x14>
 132:	07 90       	elpm	r0, Z+
 134:	0d 92       	st	X+, r0
 136:	ac 33       	cpi	r26, 0x3C	; 60
 138:	b1 07       	cpc	r27, r17
 13a:	d9 f7       	brne	.-10     	; 0x132 <__do_copy_data+0x10>

0000013c <__do_clear_bss>:
 13c:	23 e0       	ldi	r18, 0x03	; 3
 13e:	ac e3       	ldi	r26, 0x3C	; 60
 140:	b2 e0       	ldi	r27, 0x02	; 2
 142:	01 c0       	rjmp	.+2      	; 0x146 <.do_clear_bss_start>

00000144 <.do_clear_bss_loop>:
 144:	1d 92       	st	X+, r1

00000146 <.do_clear_bss_start>:
 146:	a6 3a       	cpi	r26, 0xA6	; 166
 148:	b2 07       	cpc	r27, r18
 14a:	e1 f7       	brne	.-8      	; 0x144 <.do_clear_bss_loop>
 14c:	86 d0       	rcall	.+268    	; 0x25a <main>
 14e:	0a c2       	rjmp	.+1044   	; 0x564 <_exit>

00000150 <__bad_interrupt>:
 150:	57 cf       	rjmp	.-338    	; 0x0 <__vectors>

00000152 <__vector_20>:
} tCANSpeed;

tConfig* configuration;

ISR (TIMER1_OVF_vect)    // Timer1 ISR
{
 152:	1f 92       	push	r1
 154:	0f 92       	push	r0
 156:	0f b6       	in	r0, 0x3f	; 63
 158:	0f 92       	push	r0
 15a:	11 24       	eor	r1, r1
 15c:	0b b6       	in	r0, 0x3b	; 59
 15e:	0f 92       	push	r0
 160:	8f 93       	push	r24
 162:	9f 93       	push	r25
 164:	ef 93       	push	r30
 166:	ff 93       	push	r31
	//PORTB ^= (1 << PB7);	// pb7 ist high
	liveData[1] += 1;
 168:	ee e9       	ldi	r30, 0x9E	; 158
 16a:	f2 e0       	ldi	r31, 0x02	; 2
 16c:	81 81       	ldd	r24, Z+1	; 0x01
 16e:	8f 5f       	subi	r24, 0xFF	; 255
 170:	81 83       	std	Z+1, r24	; 0x01
	
	if ( liveData[1] == 170)
 172:	8a 3a       	cpi	r24, 0xAA	; 170
 174:	19 f4       	brne	.+6      	; 0x17c <__vector_20+0x2a>
	{
		liveData[1] = 100;
 176:	84 e6       	ldi	r24, 0x64	; 100
 178:	80 93 9f 02 	sts	0x029F, r24	; 0x80029f <liveData+0x1>
	}
	
	liveData[3]++;
 17c:	ee e9       	ldi	r30, 0x9E	; 158
 17e:	f2 e0       	ldi	r31, 0x02	; 2
 180:	83 81       	ldd	r24, Z+3	; 0x03
 182:	8f 5f       	subi	r24, 0xFF	; 255
 184:	83 83       	std	Z+3, r24	; 0x03
	
	if (liveData[3] == 130)
 186:	82 38       	cpi	r24, 0x82	; 130
 188:	19 f4       	brne	.+6      	; 0x190 <__vector_20+0x3e>
	{
		liveData[3] = 68;
 18a:	84 e4       	ldi	r24, 0x44	; 68
 18c:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <liveData+0x3>
	}


	liveData[0]++;
 190:	ee e9       	ldi	r30, 0x9E	; 158
 192:	f2 e0       	ldi	r31, 0x02	; 2
 194:	80 81       	ld	r24, Z
 196:	8f 5f       	subi	r24, 0xFF	; 255
 198:	80 83       	st	Z, r24
	PORTB ^= (1 << PB7);
 19a:	85 b1       	in	r24, 0x05	; 5
 19c:	80 58       	subi	r24, 0x80	; 128
 19e:	85 b9       	out	0x05, r24	; 5
	
	TCNT1 = tcnt1_preload;   // for 1 sec at 16 MHz
 1a0:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <tcnt1_preload>
 1a4:	90 91 2e 02 	lds	r25, 0x022E	; 0x80022e <tcnt1_preload+0x1>
 1a8:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x7c0085>
 1ac:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x7c0084>
}
 1b0:	ff 91       	pop	r31
 1b2:	ef 91       	pop	r30
 1b4:	9f 91       	pop	r25
 1b6:	8f 91       	pop	r24
 1b8:	0f 90       	pop	r0
 1ba:	0b be       	out	0x3b, r0	; 59
 1bc:	0f 90       	pop	r0
 1be:	0f be       	out	0x3f, r0	; 63
 1c0:	0f 90       	pop	r0
 1c2:	1f 90       	pop	r1
 1c4:	18 95       	reti

000001c6 <__vector_51>:


ISR(USART2_RX_vect)
{
 1c6:	1f 92       	push	r1
 1c8:	0f 92       	push	r0
 1ca:	0f b6       	in	r0, 0x3f	; 63
 1cc:	0f 92       	push	r0
 1ce:	11 24       	eor	r1, r1
 1d0:	0b b6       	in	r0, 0x3b	; 59
 1d2:	0f 92       	push	r0
 1d4:	2f 93       	push	r18
 1d6:	3f 93       	push	r19
 1d8:	4f 93       	push	r20
 1da:	5f 93       	push	r21
 1dc:	6f 93       	push	r22
 1de:	7f 93       	push	r23
 1e0:	8f 93       	push	r24
 1e2:	9f 93       	push	r25
 1e4:	af 93       	push	r26
 1e6:	bf 93       	push	r27
 1e8:	ef 93       	push	r30
 1ea:	ff 93       	push	r31
	uint8_t data;
	
	data = UDR2;
 1ec:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7c00d6>
	
	switch (data)
 1f0:	89 34       	cpi	r24, 0x49	; 73
 1f2:	d9 f0       	breq	.+54     	; 0x22a <__vector_51+0x64>
 1f4:	28 f4       	brcc	.+10     	; 0x200 <__vector_51+0x3a>
 1f6:	81 34       	cpi	r24, 0x41	; 65
 1f8:	41 f0       	breq	.+16     	; 0x20a <__vector_51+0x44>
 1fa:	86 34       	cpi	r24, 0x46	; 70
 1fc:	51 f0       	breq	.+20     	; 0x212 <__vector_51+0x4c>
 1fe:	1a c0       	rjmp	.+52     	; 0x234 <__vector_51+0x6e>
 200:	8c 34       	cpi	r24, 0x4C	; 76
 202:	b1 f0       	breq	.+44     	; 0x230 <__vector_51+0x6a>
 204:	86 35       	cpi	r24, 0x56	; 86
 206:	59 f0       	breq	.+22     	; 0x21e <__vector_51+0x58>
 208:	15 c0       	rjmp	.+42     	; 0x234 <__vector_51+0x6e>
	{
		case 'A':
		PORTB ^= (1 << PB7);	// pb7 ist high
 20a:	85 b1       	in	r24, 0x05	; 5
 20c:	80 58       	subi	r24, 0x80	; 128
 20e:	85 b9       	out	0x05, r24	; 5
		break;
 210:	11 c0       	rjmp	.+34     	; 0x234 <__vector_51+0x6e>
		case 'F':
		uart2_sendS((uint8_t*) string, sizeof(string)-1);
 212:	68 e2       	ldi	r22, 0x28	; 40
 214:	70 e0       	ldi	r23, 0x00	; 0
 216:	80 e0       	ldi	r24, 0x00	; 0
 218:	92 e0       	ldi	r25, 0x02	; 2
 21a:	50 d1       	rcall	.+672    	; 0x4bc <uart2_sendS>
		break;
 21c:	0b c0       	rjmp	.+22     	; 0x234 <__vector_51+0x6e>
		
		case 'V':	// reading controller settings
		uart2_sendS((uint8_t*) controllerSettings, sizeof(controllerSettings));
 21e:	69 e0       	ldi	r22, 0x09	; 9
 220:	70 e0       	ldi	r23, 0x00	; 0
 222:	88 e5       	ldi	r24, 0x58	; 88
 224:	93 e0       	ldi	r25, 0x03	; 3
 226:	4a d1       	rcall	.+660    	; 0x4bc <uart2_sendS>
		break;
		
		case 'I':
		// uart2_sendS((uint8_t*) ip_values, sizeof(ip_values));
		uart2_sendC(sizeof(eeprom_ip));
 228:	05 c0       	rjmp	.+10     	; 0x234 <__vector_51+0x6e>
 22a:	80 e3       	ldi	r24, 0x30	; 48
		
		break;
 22c:	25 d1       	rcall	.+586    	; 0x478 <uart2_sendC>
		
		case 'L':
		// uart2_sendS((uint8_t*) lambda_values, sizeof(lambda_values));
		uart2_sendC(sizeof(eeprom_lambda));
 22e:	02 c0       	rjmp	.+4      	; 0x234 <__vector_51+0x6e>
 230:	80 e3       	ldi	r24, 0x30	; 48
 232:	22 d1       	rcall	.+580    	; 0x478 <uart2_sendC>
		break;
	}
}
 234:	ff 91       	pop	r31
 236:	ef 91       	pop	r30
 238:	bf 91       	pop	r27
 23a:	af 91       	pop	r26
 23c:	9f 91       	pop	r25
 23e:	8f 91       	pop	r24
 240:	7f 91       	pop	r23
 242:	6f 91       	pop	r22
 244:	5f 91       	pop	r21
 246:	4f 91       	pop	r20
 248:	3f 91       	pop	r19
 24a:	2f 91       	pop	r18
 24c:	0f 90       	pop	r0
 24e:	0b be       	out	0x3b, r0	; 59
 250:	0f 90       	pop	r0
 252:	0f be       	out	0x3f, r0	; 63
 254:	0f 90       	pop	r0
 256:	1f 90       	pop	r1
 258:	18 95       	reti

0000025a <main>:

int main(void)
{
	uart_init();
 25a:	cf d0       	rcall	.+414    	; 0x3fa <uart_init>
	uart2_sendS((uint8_t*) "reboot!", 7);
 25c:	67 e0       	ldi	r22, 0x07	; 7
 25e:	70 e0       	ldi	r23, 0x00	; 0
 260:	8f e2       	ldi	r24, 0x2F	; 47
 262:	92 e0       	ldi	r25, 0x02	; 2
 264:	2b d1       	rcall	.+598    	; 0x4bc <uart2_sendS>
	

	DDRB |= (1 << PB7);		// pb7 ist ausgang
 266:	84 b1       	in	r24, 0x04	; 4
 268:	80 68       	ori	r24, 0x80	; 128
 26a:	84 b9       	out	0x04, r24	; 4
	// PORTB |= (1 << PB7);	// pb7 ist high

	eeprom_read_block((void*)signature, (const void*) eeprom_signature, sizeof(eeprom_signature));
 26c:	4e e1       	ldi	r20, 0x1E	; 30
 26e:	50 e0       	ldi	r21, 0x00	; 0
 270:	6e e8       	ldi	r22, 0x8E	; 142
 272:	70 e0       	ldi	r23, 0x00	; 0
 274:	8a e3       	ldi	r24, 0x3A	; 58
 276:	93 e0       	ldi	r25, 0x03	; 3
 278:	44 d1       	rcall	.+648    	; 0x502 <eeprom_read_block>
	eeprom_read_block((void*)versionInfo, (const void*) eeprom_versionInfo, sizeof(eeprom_versionInfo));
 27a:	45 e2       	ldi	r20, 0x25	; 37
 27c:	50 e0       	ldi	r21, 0x00	; 0
 27e:	69 e6       	ldi	r22, 0x69	; 105
 280:	70 e0       	ldi	r23, 0x00	; 0
 282:	81 e8       	ldi	r24, 0x81	; 129
 284:	93 e0       	ldi	r25, 0x03	; 3
 286:	3d d1       	rcall	.+634    	; 0x502 <eeprom_read_block>
	eeprom_read_block((void*)controllerSettings, (const void*) eeprom_config, sizeof(eeprom_config));
 288:	49 e0       	ldi	r20, 0x09	; 9
 28a:	50 e0       	ldi	r21, 0x00	; 0
 28c:	60 e6       	ldi	r22, 0x60	; 96
 28e:	70 e0       	ldi	r23, 0x00	; 0
 290:	88 e5       	ldi	r24, 0x58	; 88
 292:	93 e0       	ldi	r25, 0x03	; 3
 294:	36 d1       	rcall	.+620    	; 0x502 <eeprom_read_block>
	
	eeprom_read_block((void*)ip_values, (const void*) eeprom_ip, sizeof(eeprom_ip));
 296:	40 e3       	ldi	r20, 0x30	; 48
 298:	50 e0       	ldi	r21, 0x00	; 0
 29a:	60 e3       	ldi	r22, 0x30	; 48
 29c:	70 e0       	ldi	r23, 0x00	; 0
 29e:	8c e3       	ldi	r24, 0x3C	; 60
 2a0:	92 e0       	ldi	r25, 0x02	; 2
 2a2:	2f d1       	rcall	.+606    	; 0x502 <eeprom_read_block>
	eeprom_read_block((void*)lambda_values, (const void*) eeprom_lambda, sizeof(eeprom_lambda));
 2a4:	40 e3       	ldi	r20, 0x30	; 48
 2a6:	50 e0       	ldi	r21, 0x00	; 0
 2a8:	60 e0       	ldi	r22, 0x00	; 0
 2aa:	70 e0       	ldi	r23, 0x00	; 0
 2ac:	8a ed       	ldi	r24, 0xDA	; 218
 2ae:	92 e0       	ldi	r25, 0x02	; 2
 2b0:	28 d1       	rcall	.+592    	; 0x502 <eeprom_read_block>
	
 	configuration = (tConfig*)controllerSettings;
 2b2:	88 e5       	ldi	r24, 0x58	; 88
 2b4:	93 e0       	ldi	r25, 0x03	; 3
 2b6:	90 93 9d 02 	sts	0x029D, r25	; 0x80029d <configuration+0x1>
 2ba:	80 93 9c 02 	sts	0x029C, r24	; 0x80029c <configuration>
	
	init_1s_timer();
 2be:	8a d0       	rcall	.+276    	; 0x3d4 <init_1s_timer>
 2c0:	78 94       	sei
		
	sei();
 2c2:	ee e9       	ldi	r30, 0x9E	; 158

	uint8_t offset;
	uint8_t value;
	uint8_t pageIdentifier = 0;
	
	liveData[1] = 127;
 2c4:	f2 e0       	ldi	r31, 0x02	; 2
 2c6:	8f e7       	ldi	r24, 0x7F	; 127
 2c8:	81 83       	std	Z+1, r24	; 0x01
 2ca:	84 e6       	ldi	r24, 0x64	; 100
	liveData[2] = 100;
 2cc:	82 83       	std	Z+2, r24	; 0x02
 2ce:	8c e5       	ldi	r24, 0x5C	; 92
	liveData[3] = 92;
 2d0:	83 83       	std	Z+3, r24	; 0x03
 2d2:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <pwm1>
	
	liveData[4] = (uint8_t)(pwm1 & 0xFF);
 2d6:	90 91 2c 02 	lds	r25, 0x022C	; 0x80022c <pwm1+0x1>
 2da:	84 83       	std	Z+4, r24	; 0x04
 2dc:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <pwm1>
	liveData[5] = (uint8_t)(pwm1 >> 8);
 2e0:	90 91 2c 02 	lds	r25, 0x022C	; 0x80022c <pwm1+0x1>
 2e4:	95 83       	std	Z+5, r25	; 0x05
 2e6:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <pwm2>
	
	liveData[6] = (uint8_t)(pwm2 & 0xFF);
 2ea:	90 91 2a 02 	lds	r25, 0x022A	; 0x80022a <pwm2+0x1>
 2ee:	86 83       	std	Z+6, r24	; 0x06
	liveData[7] = (uint8_t)(pwm2 >> 8);
 2f0:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <pwm2>
 2f4:	90 91 2a 02 	lds	r25, 0x022A	; 0x80022a <pwm2+0x1>
 2f8:	97 83       	std	Z+7, r25	; 0x07
	
	liveData[24] = 0;
 2fa:	10 8e       	std	Z+24, r1	; 0x18
	sei();
	

	uint8_t offset;
	uint8_t value;
	uint8_t pageIdentifier = 0;
 2fc:	d0 e0       	ldi	r29, 0x00	; 0

	
    /* Replace with your application code */
    while (1) 
    {
		switch (uart_getData())
 2fe:	ab d0       	rcall	.+342    	; 0x456 <uart_getData>
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	fc 01       	movw	r30, r24
 304:	e1 54       	subi	r30, 0x41	; 65
 306:	f1 09       	sbc	r31, r1
 308:	e7 31       	cpi	r30, 0x17	; 23
 30a:	f1 05       	cpc	r31, r1
 30c:	c0 f7       	brcc	.-16     	; 0x2fe <main+0xa4>
 30e:	88 27       	eor	r24, r24
 310:	ee 58       	subi	r30, 0x8E	; 142
 312:	ff 4f       	sbci	r31, 0xFF	; 255
 314:	8f 4f       	sbci	r24, 0xFF	; 255
 316:	ed c0       	rjmp	.+474    	; 0x4f2 <__tablejump2__>
		{
			case 'F':	// serial protocol version request
				uart_sendS((uint8_t*) "001", 3);
 318:	63 e0       	ldi	r22, 0x03	; 3
 31a:	70 e0       	ldi	r23, 0x00	; 0
 31c:	87 e3       	ldi	r24, 0x37	; 55
 31e:	92 e0       	ldi	r25, 0x02	; 2
 320:	b2 d0       	rcall	.+356    	; 0x486 <uart_sendS>
				break;
			case 'Q':	// code version
				uart_sendS((uint8_t*) signature, sizeof(signature));
 322:	ed cf       	rjmp	.-38     	; 0x2fe <main+0xa4>
 324:	6e e1       	ldi	r22, 0x1E	; 30
 326:	70 e0       	ldi	r23, 0x00	; 0
 328:	8a e3       	ldi	r24, 0x3A	; 58
 32a:	93 e0       	ldi	r25, 0x03	; 3
 32c:	ac d0       	rcall	.+344    	; 0x486 <uart_sendS>
				break;
 32e:	e7 cf       	rjmp	.-50     	; 0x2fe <main+0xa4>
				
			case 'S':	// signature, has to be the same like in ini-file
				uart_sendS((uint8_t*) versionInfo, sizeof(versionInfo)-1);
 330:	64 e2       	ldi	r22, 0x24	; 36
 332:	70 e0       	ldi	r23, 0x00	; 0
 334:	81 e8       	ldi	r24, 0x81	; 129
 336:	93 e0       	ldi	r25, 0x03	; 3
 338:	a6 d0       	rcall	.+332    	; 0x486 <uart_sendS>
				break;
 33a:	e1 cf       	rjmp	.-62     	; 0x2fe <main+0xa4>
				
			case 'V':	// reading controller settings
				if (pageIdentifier == 0x01)
 33c:	d1 30       	cpi	r29, 0x01	; 1
				{
					uart_sendS((uint8_t*) controllerSettings, sizeof(controllerSettings));										
 33e:	29 f4       	brne	.+10     	; 0x34a <main+0xf0>
 340:	69 e0       	ldi	r22, 0x09	; 9
 342:	70 e0       	ldi	r23, 0x00	; 0
 344:	88 e5       	ldi	r24, 0x58	; 88
 346:	93 e0       	ldi	r25, 0x03	; 3
				}
				
				if (pageIdentifier == 0x02)
 348:	9e d0       	rcall	.+316    	; 0x486 <uart_sendS>
 34a:	d2 30       	cpi	r29, 0x02	; 2
				{
					uart_sendS((uint8_t*) ip_values, 48);
 34c:	c1 f6       	brne	.-80     	; 0x2fe <main+0xa4>
 34e:	60 e3       	ldi	r22, 0x30	; 48
 350:	70 e0       	ldi	r23, 0x00	; 0
 352:	8c e3       	ldi	r24, 0x3C	; 60
					uart_sendS((uint8_t*) lambda_values, 48);
 354:	92 e0       	ldi	r25, 0x02	; 2
 356:	97 d0       	rcall	.+302    	; 0x486 <uart_sendS>
 358:	60 e3       	ldi	r22, 0x30	; 48
 35a:	70 e0       	ldi	r23, 0x00	; 0
 35c:	8a ed       	ldi	r24, 0xDA	; 218
				}
				
				break;
				
			case 'A':	// reading live data
				uart_sendS((uint8_t*) liveData, sizeof(liveData));
 35e:	92 e0       	ldi	r25, 0x02	; 2
 360:	92 d0       	rcall	.+292    	; 0x486 <uart_sendS>
 362:	cd cf       	rjmp	.-102    	; 0x2fe <main+0xa4>
 364:	6c e1       	ldi	r22, 0x1C	; 28
 366:	70 e0       	ldi	r23, 0x00	; 0
 368:	8e e9       	ldi	r24, 0x9E	; 158
				break;
 36a:	92 e0       	ldi	r25, 0x02	; 2
				
			case 'W':	// update controller config string
				while (!uart_hasData()) {};	// wait for offset
 36c:	8c d0       	rcall	.+280    	; 0x486 <uart_sendS>
 36e:	c7 cf       	rjmp	.-114    	; 0x2fe <main+0xa4>
 370:	7b d0       	rcall	.+246    	; 0x468 <uart_hasData>
				offset = uart_getData();
 372:	88 23       	and	r24, r24
 374:	e9 f3       	breq	.-6      	; 0x370 <main+0x116>
				while (!uart_hasData()) {};	// wait for value
 376:	6f d0       	rcall	.+222    	; 0x456 <uart_getData>
 378:	c8 2f       	mov	r28, r24
 37a:	76 d0       	rcall	.+236    	; 0x468 <uart_hasData>
				value = uart_getData();
 37c:	88 23       	and	r24, r24
 37e:	e9 f3       	breq	.-6      	; 0x37a <main+0x120>
				controllerSettings[offset] = value;
 380:	6a d0       	rcall	.+212    	; 0x456 <uart_getData>
 382:	ec 2f       	mov	r30, r28
 384:	f0 e0       	ldi	r31, 0x00	; 0
 386:	e8 5a       	subi	r30, 0xA8	; 168
				break;
 388:	fc 4f       	sbci	r31, 0xFC	; 252
				
			case 'E':	// execute button command, this command is always 3 byte long
				multiByteCommandBuffer[0] = 'E';
 38a:	80 83       	st	Z, r24
 38c:	b8 cf       	rjmp	.-144    	; 0x2fe <main+0xa4>
 38e:	85 e4       	ldi	r24, 0x45	; 69
				
				while (!uart_hasData()) {};
 390:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <multiByteCommandBuffer>
 394:	69 d0       	rcall	.+210    	; 0x468 <uart_hasData>
				multiByteCommandBuffer[1] = uart_getData();
 396:	88 23       	and	r24, r24
 398:	e9 f3       	breq	.-6      	; 0x394 <main+0x13a>
 39a:	5d d0       	rcall	.+186    	; 0x456 <uart_getData>
			
				while (!uart_hasData()) {};
 39c:	80 93 bb 02 	sts	0x02BB, r24	; 0x8002bb <multiByteCommandBuffer+0x1>
 3a0:	63 d0       	rcall	.+198    	; 0x468 <uart_hasData>
				multiByteCommandBuffer[2] = uart_getData();
 3a2:	88 23       	and	r24, r24
 3a4:	e9 f3       	breq	.-6      	; 0x3a0 <main+0x146>
 3a6:	57 d0       	rcall	.+174    	; 0x456 <uart_getData>
 3a8:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <multiByteCommandBuffer+0x2>
				
				uart2_sendS((uint8_t*) multiByteCommandBuffer, 3);
 3ac:	63 e0       	ldi	r22, 0x03	; 3
 3ae:	70 e0       	ldi	r23, 0x00	; 0
 3b0:	8a eb       	ldi	r24, 0xBA	; 186
 3b2:	92 e0       	ldi	r25, 0x02	; 2
 3b4:	83 d0       	rcall	.+262    	; 0x4bc <uart2_sendS>
				break;
 3b6:	a3 cf       	rjmp	.-186    	; 0x2fe <main+0xa4>
				
			case 'B':	// push controller config string to eeprom
				eeprom_update_block((const void*) &controllerSettings, (void*) eeprom_config, sizeof(eeprom_config));
 3b8:	49 e0       	ldi	r20, 0x09	; 9
 3ba:	50 e0       	ldi	r21, 0x00	; 0
 3bc:	60 e6       	ldi	r22, 0x60	; 96
 3be:	70 e0       	ldi	r23, 0x00	; 0
 3c0:	88 e5       	ldi	r24, 0x58	; 88
 3c2:	93 e0       	ldi	r25, 0x03	; 3
 3c4:	ae d0       	rcall	.+348    	; 0x522 <eeprom_update_block>
 3c6:	9b cf       	rjmp	.-202    	; 0x2fe <main+0xa4>
				break;
 3c8:	4f d0       	rcall	.+158    	; 0x468 <uart_hasData>
				
			case 'P':
				while (!uart_hasData()) {};
 3ca:	88 23       	and	r24, r24
 3cc:	e9 f3       	breq	.-6      	; 0x3c8 <main+0x16e>
 3ce:	43 d0       	rcall	.+134    	; 0x456 <uart_getData>
 3d0:	d8 2f       	mov	r29, r24
				pageIdentifier = uart_getData();
 3d2:	95 cf       	rjmp	.-214    	; 0x2fe <main+0xa4>

000003d4 <init_1s_timer>:

void init_1s_timer (void)
{
	// 1s: prescale = 256 and preload = 3036
	// 1s: prescale = 1024 and preload = 49911
	TCNT1 = tcnt1_preload;
 3d4:	80 91 2d 02 	lds	r24, 0x022D	; 0x80022d <tcnt1_preload>
 3d8:	90 91 2e 02 	lds	r25, 0x022E	; 0x80022e <tcnt1_preload+0x1>
 3dc:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__TEXT_REGION_LENGTH__+0x7c0085>
 3e0:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <__TEXT_REGION_LENGTH__+0x7c0084>
	TCCR1A = 0x00;
 3e4:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7c0080>
	TCCR1B |= (1<<CS12);		// Timer mode with 1024 prescler
 3e8:	e1 e8       	ldi	r30, 0x81	; 129
 3ea:	f0 e0       	ldi	r31, 0x00	; 0
 3ec:	80 81       	ld	r24, Z
 3ee:	84 60       	ori	r24, 0x04	; 4
 3f0:	80 83       	st	Z, r24
	TIMSK1 = (1 << TOIE1);		// Enable timer1 overflow interrupt(TOIE1)
 3f2:	81 e0       	ldi	r24, 0x01	; 1
 3f4:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7c006f>
 3f8:	08 95       	ret

000003fa <uart_init>:

void uart_init (void)
{
	uint8_t dummy;
	
	UBRR3 = 8;
 3fa:	88 e0       	ldi	r24, 0x08	; 8
 3fc:	90 e0       	ldi	r25, 0x00	; 0
 3fe:	90 93 35 01 	sts	0x0135, r25	; 0x800135 <__TEXT_REGION_LENGTH__+0x7c0135>
 402:	80 93 34 01 	sts	0x0134, r24	; 0x800134 <__TEXT_REGION_LENGTH__+0x7c0134>
	// UCSR3B = (1 << RXEN3)|(1 << TXEN3)|(1 << RXCIE3);
	UCSR3B = (1 << RXEN3)|(1 << TXEN3);
 406:	88 e1       	ldi	r24, 0x18	; 24
 408:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <__TEXT_REGION_LENGTH__+0x7c0131>
	UCSR3C = (1 << UCSZ31)|(1 << UCSZ30);
 40c:	86 e0       	ldi	r24, 0x06	; 6
 40e:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__TEXT_REGION_LENGTH__+0x7c0132>
	
	// flush receiver buffer;
	while ( UCSR3A & (1<<RXC3) ) dummy = UDR3;
 412:	02 c0       	rjmp	.+4      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 414:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x7c0136>
 418:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x7c0130>
 41c:	88 23       	and	r24, r24
 41e:	d4 f3       	brlt	.-12     	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
	
	UBRR2 = 8;
 420:	88 e0       	ldi	r24, 0x08	; 8
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	90 93 d5 00 	sts	0x00D5, r25	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7c00d5>
 428:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7c00d4>
	UCSR2B = (1 << RXEN2)|(1 << TXEN2)|(1 << RXCIE2);
 42c:	88 e9       	ldi	r24, 0x98	; 152
 42e:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7c00d1>
	UCSR2C = (1 << UCSZ21)|(1 << UCSZ20);
 432:	86 e0       	ldi	r24, 0x06	; 6
 434:	80 93 d2 00 	sts	0x00D2, r24	; 0x8000d2 <__TEXT_REGION_LENGTH__+0x7c00d2>
	
	// flush receiver buffer;
	while ( UCSR2A & (1<<RXC2) ) dummy = UDR2;
 438:	02 c0       	rjmp	.+4      	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
 43a:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7c00d6>
 43e:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7c00d0>
 442:	88 23       	and	r24, r24
 444:	d4 f3       	brlt	.-12     	; 0x43a <__LOCK_REGION_LENGTH__+0x3a>
}
 446:	08 95       	ret

00000448 <uart_sendC>:

void uart_sendC (const uint8_t data)
{
	while (!(UCSR3A & (1 << UDRE3)));
 448:	90 91 30 01 	lds	r25, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x7c0130>
 44c:	95 ff       	sbrs	r25, 5
 44e:	fc cf       	rjmp	.-8      	; 0x448 <uart_sendC>
	UDR3 = data;
 450:	80 93 36 01 	sts	0x0136, r24	; 0x800136 <__TEXT_REGION_LENGTH__+0x7c0136>
 454:	08 95       	ret

00000456 <uart_getData>:
}

uint8_t uart_getData (void)
{
	if (UCSR3A & (1<<RXC3)) 
 456:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x7c0130>
 45a:	88 23       	and	r24, r24
 45c:	1c f4       	brge	.+6      	; 0x464 <uart_getData+0xe>
	{
		return UDR3;
 45e:	80 91 36 01 	lds	r24, 0x0136	; 0x800136 <__TEXT_REGION_LENGTH__+0x7c0136>
 462:	08 95       	ret
	}
	else 
	{
		return 0;
 464:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 466:	08 95       	ret

00000468 <uart_hasData>:


bool uart_hasData (void)
{
	if (UCSR3A & (1<<RXC3))
 468:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <__TEXT_REGION_LENGTH__+0x7c0130>
 46c:	88 23       	and	r24, r24
 46e:	14 f4       	brge	.+4      	; 0x474 <uart_hasData+0xc>
	{
		return true;
 470:	81 e0       	ldi	r24, 0x01	; 1
 472:	08 95       	ret
	}
	else
	{
		return false;
 474:	80 e0       	ldi	r24, 0x00	; 0
	}
}
 476:	08 95       	ret

00000478 <uart2_sendC>:

void uart2_sendC (const uint8_t data)
{
	while (!(UCSR2A & (1 << UDRE2)));
 478:	90 91 d0 00 	lds	r25, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7c00d0>
 47c:	95 ff       	sbrs	r25, 5
 47e:	fc cf       	rjmp	.-8      	; 0x478 <uart2_sendC>
	UDR2 = data;
 480:	80 93 d6 00 	sts	0x00D6, r24	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7c00d6>
 484:	08 95       	ret

00000486 <uart_sendS>:
}

void uart_sendS(const uint8_t *pData, uint16_t size)
{
 486:	ef 92       	push	r14
 488:	ff 92       	push	r15
 48a:	0f 93       	push	r16
 48c:	1f 93       	push	r17
 48e:	cf 93       	push	r28
 490:	df 93       	push	r29
 492:	7c 01       	movw	r14, r24
 494:	8b 01       	movw	r16, r22
	uint16_t cnt = 0;
 496:	c0 e0       	ldi	r28, 0x00	; 0
 498:	d0 e0       	ldi	r29, 0x00	; 0
	
	while (cnt < size)
 49a:	06 c0       	rjmp	.+12     	; 0x4a8 <uart_sendS+0x22>
	{
		uart_sendC(pData[cnt]);
 49c:	f7 01       	movw	r30, r14
 49e:	ec 0f       	add	r30, r28
 4a0:	fd 1f       	adc	r31, r29
 4a2:	80 81       	ld	r24, Z
 4a4:	d1 df       	rcall	.-94     	; 0x448 <uart_sendC>
		cnt++;
 4a6:	21 96       	adiw	r28, 0x01	; 1

void uart_sendS(const uint8_t *pData, uint16_t size)
{
	uint16_t cnt = 0;
	
	while (cnt < size)
 4a8:	c0 17       	cp	r28, r16
 4aa:	d1 07       	cpc	r29, r17
 4ac:	b8 f3       	brcs	.-18     	; 0x49c <uart_sendS+0x16>
	{
		uart_sendC(pData[cnt]);
		cnt++;
	}
}
 4ae:	df 91       	pop	r29
 4b0:	cf 91       	pop	r28
 4b2:	1f 91       	pop	r17
 4b4:	0f 91       	pop	r16
 4b6:	ff 90       	pop	r15
 4b8:	ef 90       	pop	r14
 4ba:	08 95       	ret

000004bc <uart2_sendS>:

void uart2_sendS(const uint8_t *pData, uint16_t size)
{
 4bc:	ef 92       	push	r14
 4be:	ff 92       	push	r15
 4c0:	0f 93       	push	r16
 4c2:	1f 93       	push	r17
 4c4:	cf 93       	push	r28
 4c6:	df 93       	push	r29
 4c8:	7c 01       	movw	r14, r24
 4ca:	8b 01       	movw	r16, r22
	uint16_t cnt = 0;
 4cc:	c0 e0       	ldi	r28, 0x00	; 0
 4ce:	d0 e0       	ldi	r29, 0x00	; 0
	
	while (cnt < size)
 4d0:	06 c0       	rjmp	.+12     	; 0x4de <uart2_sendS+0x22>
	{
		uart2_sendC(pData[cnt]);
 4d2:	f7 01       	movw	r30, r14
 4d4:	ec 0f       	add	r30, r28
 4d6:	fd 1f       	adc	r31, r29
 4d8:	80 81       	ld	r24, Z
 4da:	ce df       	rcall	.-100    	; 0x478 <uart2_sendC>
		cnt++;
 4dc:	21 96       	adiw	r28, 0x01	; 1

void uart2_sendS(const uint8_t *pData, uint16_t size)
{
	uint16_t cnt = 0;
	
	while (cnt < size)
 4de:	c0 17       	cp	r28, r16
 4e0:	d1 07       	cpc	r29, r17
 4e2:	b8 f3       	brcs	.-18     	; 0x4d2 <uart2_sendS+0x16>
	{
		uart2_sendC(pData[cnt]);
		cnt++;
	}
}
 4e4:	df 91       	pop	r29
 4e6:	cf 91       	pop	r28
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	08 95       	ret

000004f2 <__tablejump2__>:
 4f2:	ee 0f       	add	r30, r30
 4f4:	ff 1f       	adc	r31, r31
 4f6:	88 1f       	adc	r24, r24
 4f8:	8b bf       	out	0x3b, r24	; 59
 4fa:	07 90       	elpm	r0, Z+
 4fc:	f6 91       	elpm	r31, Z
 4fe:	e0 2d       	mov	r30, r0
 500:	19 94       	eijmp

00000502 <eeprom_read_block>:
 502:	dc 01       	movw	r26, r24
 504:	cb 01       	movw	r24, r22

00000506 <eeprom_read_blraw>:
 506:	fc 01       	movw	r30, r24
 508:	f9 99       	sbic	0x1f, 1	; 31
 50a:	fe cf       	rjmp	.-4      	; 0x508 <eeprom_read_blraw+0x2>
 50c:	06 c0       	rjmp	.+12     	; 0x51a <eeprom_read_blraw+0x14>
 50e:	f2 bd       	out	0x22, r31	; 34
 510:	e1 bd       	out	0x21, r30	; 33
 512:	f8 9a       	sbi	0x1f, 0	; 31
 514:	31 96       	adiw	r30, 0x01	; 1
 516:	00 b4       	in	r0, 0x20	; 32
 518:	0d 92       	st	X+, r0
 51a:	41 50       	subi	r20, 0x01	; 1
 51c:	50 40       	sbci	r21, 0x00	; 0
 51e:	b8 f7       	brcc	.-18     	; 0x50e <eeprom_read_blraw+0x8>
 520:	08 95       	ret

00000522 <eeprom_update_block>:
 522:	dc 01       	movw	r26, r24
 524:	a4 0f       	add	r26, r20
 526:	b5 1f       	adc	r27, r21
 528:	41 50       	subi	r20, 0x01	; 1
 52a:	50 40       	sbci	r21, 0x00	; 0
 52c:	40 f0       	brcs	.+16     	; 0x53e <eeprom_update_block+0x1c>
 52e:	cb 01       	movw	r24, r22
 530:	84 0f       	add	r24, r20
 532:	95 1f       	adc	r25, r21
 534:	2e 91       	ld	r18, -X
 536:	05 d0       	rcall	.+10     	; 0x542 <eeprom_update_r18>
 538:	41 50       	subi	r20, 0x01	; 1
 53a:	50 40       	sbci	r21, 0x00	; 0
 53c:	d8 f7       	brcc	.-10     	; 0x534 <eeprom_update_block+0x12>
 53e:	08 95       	ret

00000540 <eeprom_update_byte>:
 540:	26 2f       	mov	r18, r22

00000542 <eeprom_update_r18>:
 542:	f9 99       	sbic	0x1f, 1	; 31
 544:	fe cf       	rjmp	.-4      	; 0x542 <eeprom_update_r18>
 546:	92 bd       	out	0x22, r25	; 34
 548:	81 bd       	out	0x21, r24	; 33
 54a:	f8 9a       	sbi	0x1f, 0	; 31
 54c:	01 97       	sbiw	r24, 0x01	; 1
 54e:	00 b4       	in	r0, 0x20	; 32
 550:	02 16       	cp	r0, r18
 552:	39 f0       	breq	.+14     	; 0x562 <eeprom_update_r18+0x20>
 554:	1f ba       	out	0x1f, r1	; 31
 556:	20 bd       	out	0x20, r18	; 32
 558:	0f b6       	in	r0, 0x3f	; 63
 55a:	f8 94       	cli
 55c:	fa 9a       	sbi	0x1f, 2	; 31
 55e:	f9 9a       	sbi	0x1f, 1	; 31
 560:	0f be       	out	0x3f, r0	; 63
 562:	08 95       	ret

00000564 <_exit>:
 564:	f8 94       	cli

00000566 <__stop_program>:
 566:	ff cf       	rjmp	.-2      	; 0x566 <__stop_program>

[MegaTune]
	signature      = "speeduino_ DUAL WBO Controller" ; Can expander sends a null at 20th byte.

[TunerStudio]
	signature      = "speeduino_ DUAL WBO Controller" ; Can expander sends a null at 20th byte.
	; queryCommand   = "Q"  ; Verify against signature
	; versionInfo    = "S"  ; Put this in the title bar.

	queryCommand   = "Q"  ; Verify against signature
	versionInfo    = "S"  ; firmwave version for title bar.

	; TS will try to use legacy temp units in some cases, showing "deg F" on a CLT gauge that's actually deg C
	useLegacyFTempUnits = false

	; Optimize comms for fast rusefi ECUs
	noCommReadDelay = true;
	defaultRuntimeRecordPerSec = 100;
	maxUnusedRuntimeRange = 1000;

[Constants]

#define CAN_ADDRESS_HEX = "0x100", "0x101", "0x102", "0x103", "0x104", "0x105", "0x106", "0x107", "0x108", "0x109", "0x10A", "0x10B", "0x10C"

;----------------------------------------------------------------------------
; Constants Definition
; --------------------
;
; Scalar Values
; -------------
; The scaling and translation values are used as follows:
;    msValue   = userValue / scale - translate
;    userValue = (msValue + translate) * scale
;
;
; Temperatures are fine, check out the Fielding IAC example (fastIdleT).
;
; Array Values
; ------------
; Arrays are specified just like scalars, except that they have a "shape"
; entry in the fourth parameter.  The shape allows you to define lists or
; tables, for example [8] defines a list with eight values and [2x4] defines
; a table with eight values (two rows and four columns).  Tables may be
; stored in either "X-" or "Y-order."  X-order means that memory is laid
; out like.
;
;     [x1,y1] [x2,y1]...[xn,y1] [x1,y2]...
;
; Y-order would be
;
;     [x1,y1] [x1,y2]...[x1,yn] [x2,y1]...
;
; To use the TableEditor, you must define two lists and a table, and
; the lengths of the lists must correspond to the shape of the table.
;
; Bit Fields
; ----------
; Bits are numbered 0-7, the rightmost being bit zero.  The basic
; data word that stores bit fields must be unsigned.
;
; You need NOT supply the correct number of labels matching the
; number of bits you've specified (one bit requires 2 values, two
; bits requires 4 values and so on).  If you neglect to supply enough
; labels, they will be synthesised using the sequence "1", "2" and so
; on based upon their position in the sequence (the cltType and matType
; will end up with identical lists).
;
; If you specify a label as "INVALID" (all upper case), then it will
; not be displayed in the combo box, so you can leave out values that
; make no sense.
;
;----------------------------------------------------------------------------

;   C Type                 Bits            Range                    TunerStudio INI Designation
;   ------                 ----            -----                    ---------------------------
; - char (=signed char)     8              -128 to 127               S08 (one byte offset each)
; - unsigned char           8                 0 to 255               U08
; ...............................................................................................
; - int  (=signed int)     16          -32768 to 32767               S16 (two byte offset each)
;   (= short)
; - unsigned int           16               0 to 65535               U16
;   (=unsigned short int)
; ................................................................................................
; - long  (=signed long)   32          -2³¹ to 2³¹ - 1               S32 (four byte offset each)
;   (=long int)     
; - unsigned long          32             0 to 2³² - 1               U32
;   (=unsigned long int)
; ................................................................................................
; Note that variables are signed unless designated otherwise.

	endianness				= little
	nPages					= 1
	pageSize				= 9
	burnCommand				= "B"
	pageReadCommand			= "V"
	pageValueWrite			= "W%o%v"
 
	blockReadTimeout		= 2000		;Milliseconds total timeout for reading page.
	pageActivationDelay		= 10		;Milliseconds delay after burn command.
	tsWriteBlocks			= on
	interWriteDelay			= 1
	blockingFactor			= 2048
	tableBlockingFactor		= 2048
	delayAfterPortOpen		= 1000

 ;Page 1 is main settings
page = 1
	;  name       = bits,   type,    offset, bits
	;  name       = array,  type,    offset, shape, units,     scale, translate,    lo,      hi, digits
	;  name       = scalar, type,    offset,        units,     scale, translate,    lo,      hi, digits
	
	isCANEnabled				= bits, U08, 0, [0:0], "false", "true"
	canSpeed					= bits, U08, 0, [1:2], "125kbit", "250kbit", "500kbit", "1mbit"
	interfaceActivation			= bits, U08, 0, [3:3], "Input", "CAN"
	isCANDebugEnabled			= bits, U08, 0, [4:4], "false", "true"
	unused1						= bits, U08, 0, [5:7], "1", "2", "3", "4", "5", "6", "7", "8"
	
	isChannel1Enabled 			= bits, U08, 1, [0:0], "false", "true"
	isChannel2Enabled 			= bits, U08, 1, [1:1], "false", "true"
	channel1OutputMode			= bits, U08, 1, [2:3], "Analog", "CAN", "Analog & CAN", INVALID
	channel2OutputMode			= bits, U08, 1, [4:5], "Analog", "CAN", "Analog & CAN", INVALID
	channel1AnalogOutputMode	= bits, U08, 1, [6:6], "Wideband", "Narrowband emulation"
	channel2AnalogOutputMode	= bits, U08, 1, [7:7], "Wideband", "Narrowband emulation"

	stoich_ratio				= scalar, U08, 2, ":1", 0.1, 0.0, 0.0, 25.5, 1

	channel1CANid				= bits, U16, 3, [0:10], $CAN_ADDRESS_HEX
	channel2CANid				= bits, U16, 5, [0:10], $CAN_ADDRESS_HEX
	debugMessageID				= bits, U16, 7, [0:10], $CAN_ADDRESS_HEX

[ConstantsExtensions]
	defaultValue = stoich_ratio, 14.7
	; requiresPowerCycle = nCylinders


[Menu]

;----------------------------------------------------------------------------
;  There are five pre-defined values that may be used to define your menus.
;  The first four allow access to the "standard" dialog boxes, the last one
;  merely draws a separator (horizontal line) in the menu.
;
;     std_constants
;     std_enrichments
;     std_realtime
;     std_warmup
;
;     std_separator
;
;  If you use any of the std_constants, std_enrichments or std_warmup
;  editors, they may be optionally suffixed with a page number (only
;  useful for multi-page code variants), which causes them to edit the
;  specified page.  If you leave off the page specifier, they edit logical
;  page one as specified in the Constants section.
;
;  There are four special menu names, which when used append to the standard
;  menus of the same name instead of creating a new one.  The menu names
;  are "File", "Communications", "Tools" and "Help".
;
;----------------------------------------------------------------------------

menuDialog = main
	menu = "Settings"
		subMenu = basic_config,      "Basic Configuration"
		subMenu = interface_config,      "Interface Configuration"
	  
[UserDefined]
; Enhanced TunerStudio dialogs can be defined here
; MegaTune will over look this section
; These dialogs will over-ride those in the UserDefined Section
; User defined ar loaded first, then if one by the same name is defined here,
; it will replace the MegaTune definition

; dialog = name,   Title, Layout
;
; valid options for layout are xAxis, yAxis, border
; for an xAxis, each field added will be added from right to left
; A yAxis layout will add fields from top to bottom
; A border layout will expect an additional constraint to determine placement
; valid border constraints are north, South, East, West, Center
; all 5 do not need to be filled.

; The field name can be either a constant reference, or a reference to another
; dialog which will be added.
; dialogs can be nested and can be mixed with fields
	dialog = basic_config, "Basic Configuration"
		field = "CAN enabled", isCANEnabled
		field = "CAN speed", canSpeed, {isCANEnabled}
		field = "CAN debug messages", isCANDebugEnabled, {isCANEnabled}
		field = "CAN debug message id", channel1CANid, {isCANEnabled && isCANDebugEnabled}
		field = "Interface activation", interfaceActivation
		field = ""
		field = "Stoichiometric ratio", stoich_ratio

    dialog = interface_config, "Interface Configuration"
        field = "Channel 1 enabled", isChannel1Enabled
		field = "Channel 1 output mode", channel1OutputMode, {isChannel1Enabled}
		field = "Channel 1 analog output mode", channel1AnalogOutputMode, {isChannel1Enabled && channel1OutputMode != 1}
		field = "Channel 1 CAN ID", channel1CANid, {isCANEnabled && isChannel1Enabled && (channel1OutputMode == 1 || channel1OutputMode == 2)}
		commandButton = "Test channel 1", cmdCanChannel1_test, {isCANEnabled && isChannel1Enabled && (channel1OutputMode == 1 || channel1OutputMode == 2)}
		field = ""
		field = "Channel 2 enabled", isChannel2Enabled
		field = "Channel 2 output mode", channel2OutputMode, {isChannel2Enabled}
		field = "Channel 2 analog output mode", channel2AnalogOutputMode, {isChannel2Enabled && channel2OutputMode != 1}
		field = "Channel 2 CAN ID", channel2CANid, {isCANEnabled && isChannel2Enabled && (channel2OutputMode == 1 || channel2OutputMode == 2)}
		commandButton = "Test channel 2", cmdCanChannel2_test, {isCANEnabled && isChannel2Enabled && (channel2OutputMode == 1 || channel2OutputMode == 2)}

[ControllerCommands]
; commandName    = command1, command2, commandn...
; command in standard ini format, a command name can be assigned to 1 to n commands that will be executed in order.
;         This does not include any resultant protocol envelope data, only the response data itself.

; WARNING!! These commands bypass TunerStudio's normal memory synchronization. If these commands
; alter mapped settings (Constant) memory in the controller, TunerStudio will have an out of sync condition
; and may create error messages.
; It is expected that these commands would not typically alter any ram mapped to a Constant.

cmdCanChannel1_test = "E\x01\x00"
cmdCanChannel2_test = "E\x01\x01"

[OutputChannels]
	deadValue		= { 0 } ; Convenient unchanging value.
	ochGetCommand	= "A"
	ochBlockSize	= 24

	VBatt 				= scalar, U08, 0, "V", 0.100, 0.000
	AFRValue_1			= scalar, U08, 1, "AFR O2", 0.100, 0.000
	AFRValue_2			= scalar, U08, 2, "AFR O2", 0.100, 0.000
	lambdaValue_1		= scalar, U08, 3, "", 0.100, 0.000
	lambdaValue_2		= scalar, U08, 4, "", 0.100, 0.000

	PWM_Sensor_1_raw	= scalar, U16, 5, "raw", 1.000, 0.000
	PWM_Sensor_2_raw	= scalar, U16, 7, "raw", 1.000, 0.000
	Ua_Ref_Sensor_1		= scalar, U16, 9, "raw", 1.000, 0.000
	Ua_Sensor_1			= scalar, U16, 11, "raw", 1.000, 0.000
	Ua_Ref_Sensor_1		= scalar, U16, 13, "raw", 1.000, 0.000
	Ip_Sensor_1			= scalar, U16, 15, "raw", 1.000, 0.000
	Ua_Ref_Sensor_2		= scalar, U16, 17, "raw", 1.000, 0.000
	Ua_Sensor_2			= scalar, U16, 19, "raw", 1.000, 0.000
	Ua_Ref_Sensor_2		= scalar, U16, 21, "raw", 1.000, 0.000
	Ip_Sensor_2			= scalar, U16, 23, "raw", 1.000, 0.000

	PWM_Sensor1 		= { (PWM_Sensor_1_raw / 1024.0) * 100.0 }
	PWM_Sensor2 		= { (PWM_Sensor_2_raw / 1024.0) * 100.0 }
	
[GaugeConfigurations]
;-------------------------------------------------------------------------------
;  Notes on some of the gauges.
;-------------------------------------------------------------------------------
; Define a gauge's characteristics here, then go to a specific layout
; block (Tuning or FrontPage) and use the name you've defined here to
; display that gauge in a particular position.
;
; Name  = Case-sensitive, user-defined name for this gauge configuration.
; Var   = Case-sensitive name of variable to be displayed, see the
;         OutputChannels block in this file for possible values.
; Title = Title displayed at the top of the gauge.
; Units = Units displayed below value on gauge.
; Lo    = Lower scale limit of gauge.
; Hi    = Upper scale limit of gauge.
; LoD   = Lower limit at which danger color is used for gauge background.
; LoW   = Lower limit at which warning color is used.
; HiW   = Upper limit at which warning color is used.
; HiD   = Upper limit at which danger color is used.
; vd    = Decimal places in displayed value
; ld    = Label decimal places for display of Lo and Hi, above.

;  Name                 Var             Title                   Units     Lo     Hi     LoD    LoW   HiW   HiD vd ld
gaugeCategory = "Sensor Inputs"
	G_VBatt			= VBatt,		"Battery",				"V",       8,     21,       9,     10,      17,    19,   1,   1

	G_afr1			= AFRValue_1,	"Air:Fuel Ratio 1",     "",       10,   19.4,      12,     13,      15,    16,   2,   2
	G_afr2			= AFRValue_2,	"Air:Fuel Ratio 2",     "",       10,   19.4,      12,     13,      15,    16,   2,   2

	G_lambda1       = lambdaValue_1, "Lambda 1",       		"",        0.5,  1.5,    0.5,   0.7,    2,  1.1, 2, 2
	G_lambda2       = lambdaValue_2, "Lambda 2",       		"",        0.5,  1.5,    0.5,   0.7,    2,  1.1, 2, 2

	G_PWM_Sensor1	= PWM_Sensor1,	"PWM 1 Duty Cycle",		"%",	  0,   100,     -1,    -1,   70,   80, 1, 1
	G_PWM_Sensor2	= PWM_Sensor2,	"PWM 2 Duty Cycle",		"%",	  0,   100,     -1,    -1,   70,   80, 1, 1

; gaugeCategory = "Values"


[FrontPage]
; Gauges are numbered left to right, top to bottom.
;
;    1  2  3  4
;    5  6  7  8
	gauge1 = G_VBatt
	gauge2 = G_afr1
	gauge3 = G_afr2
	gauge4 = G_lambda1
	gauge5 = G_lambda2
	gauge5 = G_PWM_Sensor1
	gauge6 = G_PWM_Sensor2

;----------------------------------------------------------------------------
; Indicators
;             expr                   off-label       on-label,       off-bg, off-fg, on-bg,  on-fg
;   indicator = { BRAKE            }, "Not Braking",   "Braking",       white, black, green,    black